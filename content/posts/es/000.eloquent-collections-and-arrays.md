---
date: 2024-02-19
title: 'Array, collection y eloquent collection en Laravel'
description: 'Conoce las diferencias entre las herramientas de manejo de datos en Laravel'
image: '/images/content/posts/eloquent-collections-and-arrays.png'
tags: ['Laravel', 'PHP', 'Tutoriales']
---

Cuando comenc√© a programar en Laravel (que tambi√©n comenc√© a codificar en PHP) recuerdo escribir c√≥digo sin mucha idea de lo que hacia, pero que de alguna manera funcionaba, no sab√≠a diferencia entre tipos de datos u objetos; para m√≠ todo era lo mismo.

Recuerdo intentar acceder a propiedades de arreglos cuando me conectaba a APIs:

```php
$data = json_decode($response);

$data[0]['name']; // FATAL ERROR
```

O llamar al m√©todo `toArray` (ni siquiera sab√≠a de donde ven√≠a ese m√©todo) solo para poder trabajar con arreglos:

```php
$users = DB::table('users')->get()->toArray();

$users[0]['name'];
```

Despu√©s aprendi que si llamabas a json_decode con el segundo par√°metro `true` podia acceder a los valores mediante la notaci√≥n _\[ \]_ y termine usando los modelos de Eloquent de una manera bastante extra√±a y fea ü§¢:

```php
$user = json_decode(json_encode(User::first()), true);

$user['name'];
```


Llego un punto en que mi c√≥digo era inmantenible, practicamente era m√°s f√°cil refactorizar todo que intentar modificarlo, lo mejor que pude hacer fue leer, leer y leer, principalmente la [documentaci√≥n oficial de laravel](https://laravel.com/docs) y alg√∫n que otro tutorial que me encontraba por internet, mi primer acercamiento fue diferenciar `array` de un `object`

Siempre tuve dudas de porque a veces funcionaba el de arriba y en otras el de abajo:
```php
$user = $response->product;

$user = $response['product'];
```

## PHP Array y PHP Object

La principal diferencia ente estos 2 tipos de datos es la manera en que accesas a su informaci√≥n.

Por un lado tenemos un Array:

```php
$data = [];

$data['name']; // siempre se accede mediante []
```

Y el otro un Object:

```php
$data = new stdClass();  // manera 'oficial' de crear un Object
// Hay muchas maneras de crear un object, habitualmente usando esta funci√≥n es cuando comunmente los creamos
$data = json_decode($response);

$data->name; // siempre se accede mediante ->
```

en comparaci√≥n los arrays se empiezan a quedar cortos pues no se puede hacer m√°s que utilizar programaci√≥n secuencial (de arriba a abajo).

Y aqu√≠ es donde la cosa se pone curiosa, pues PHP tiene funciones practicamente para todo, solo que algunos toma parametros por valor y en otras ocasiones lo toma por [referencia](https://www.php.net/manual/es/language.references.pass.php), lo cual nos deja con un c√≥digo muy raro y con poca legibilidad:
```php
// limpiar el array para quedarnos solo con los ints, ordenados de menor a mayor

$data = [4, '', 0, 'test', 32];
$data = array_filter($data, fn($item) => is_numeric($item));
asort($data);

echo $data;
```

## Laravel Collection

La comunidad de Laravel se percat√≥ de este dilema en PHP y comenz√≥ a crear la clase para manejar arreglos `Illuminate\Support\Collection`, aqu√≠ retomamos el concepto de Object, pues cada que usemos esta clase obtendremos un Object con el que podemos interactuar:

```php
use Illuminate\Support\Collection;

$data = [4, '', 0, 'test', 32];

$data = Collection::make($data); // esta es una forma muy elegante de hacerla 
$data = collect($data); // y esta es la versi√≥n corta con helper
// ambos hacen lo mismo

```

Y ahora usando los m√©todos de esta clase que puedes consultar en la [documentaci√≥n oficial](https://laravel.com/docs/12.x/collections#available-methods) es m√°s sencillo procesar esta informaci√≥n de manera legible:

```php
// limpiar el array para quedarnos solo con los ints, ordenados de menor a mayor

$data = [4, '', 0, 'test', 32];

echo Collection::make($data)
                ->filter(fn($item) => is_numeric($item))
                ->sort()
                ->all(); // este m√©todo es solo para obtener el arreglo y no el Object

```

## Eloquent Collection

¬øY que pasa con los modelos? Bueno, aqu√≠ cambia un poco la historia, pues cada que hagas una consulta a la base de datos usando los [modelos de eloquent](https://laravel.com/docs/12.x/eloquent) y usemos el m√©todo `->get()` obtendremos una Object de `Illuminate\Database\Eloquent\Collection`:

```php
$users = User::where('name', 'LIKE', "{$search}%")->get();
```

Para se honesto, si vuelves a leer la [documentaci√≥n oficial](https://laravel.com/docs/12.x/collections#available-methods) te dar√°s cuenta que puedes utilizar los mismos m√©todos que ya revisamos previamente, solo que hay una pizca de saz√≥n en este nuevo platillo, y para ello hay que entender como esta construido una Eloquent Collection

1. Es una herencia de `Illuminate\Support\Collection`:
```php
namepace Illuminate\Database\Eloquent;

class Collection extends \Illuminate\Support\Collection
{
    ...
}
```
2. Estamos lidiando siempre con in solo modelo por Eloquent Collection
3. Hay nuevos m√©todo relacionados a los modelos
4. Los modelos cuentan con [relaciones Eloquent](https://laravel.com/docs/12.x/eloquent-relationships#main-content)
5. Es una Collection enfocada a la interacci√≥n con base de datos


Tomando en cuenta lo anterior podr√°s ver que hay nuevos m√©todos que nuevamente, puedes consultar en la [documentaci√≥n oficial](https://laravel.com/docs/12.x/eloquent-collections#available-methods):

```php
$users = User::get();

$user->load('comments'); // carga una relaci√≥n

echo $users->modelKeys(); //[1, 2, 3, 4, 5]
```

## ¬øC√≥mo diferencio entre Array, Object, Collection y Eloquent Collection?

La mejor respuesta que te pueda dar es: pr√°ctica. Conforme m√°s programes en Laravel y PHP m√°s f√°cil te ser√° ir diferenciando ente un tipo de dato y otro, aunque te puedo dar un checklist 

```php

// retornan instancias de \Illuminate\Support\Collection
collect($data);
Collection::make($data);
DB::table($table)->get();

// retornn instancias de \Illuminate\Database\Eloquent\Collection
User::get();
$user->comments()->get();
$user->load('posts')->posts;

// arrays 1005 seguro
array(1, 2, 3, 4, 5);
[1, 2, 3, 4, 5];

// quiza arrays, quiza objects
$values = json_decode($data, false);
$values = json_decode($data, true);

// usa esta funci√≥n para quitarte de dudas
gettype($values);
```

Espero te haya servido esta informaci√≥n, llevo muchos a√±os trabajando con Laravel, esta es la primera vez que p√∫blico mi conocimiento, tengo mucho m√°s que compartir en futuras publicaciones de mi blog, gracias :)